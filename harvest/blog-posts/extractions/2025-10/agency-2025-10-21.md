---
kind: field_extraction
river: agency
scan_date: 2025-10-21
seeds_extracted: 4
---

# Field Extraction — Agency — 2025-10-21

## Seed 1: Taking Custody of Your Infrastructure

### Pattern
Two stories converge: someone migrating from $3000/mo Heroku to a $55 self-hosted server, and Simon Willison documenting how to prevent Claude Code from auto-deleting your session logs. Both are about reclaiming control over systems you depend on—choosing active stewardship over passive consumption.

### Tension
Managed services promise convenience but extract ongoing costs (financial or data loss). When do you trade convenience for custody?

### Coherenceism Lens
- **Primary**: Alignment over Force — Position yourself so the system works for you, not the other way around. Self-hosting isn't about rejecting services; it's about aligning costs and control with your actual needs.
- **Secondary**: Build Once, Use Forever — Infrastructure you control becomes a permanent capability. A one-time migration yields ongoing agency.

### Evidence
- Replacing a $3000/mo Heroku bill with a $55/mo server (Hacker News)
- Don't let Claude Code delete your session logs (Simon Willison)
- OpenBSD 7.8 Released (Hacker News, Lobsters) — stable, long-term infrastructure

### River Fit
Can someone reuse this tomorrow? Yes—both examples offer concrete methods: a migration path, a config change. This is practical empowerment.

---

## Seed 2: Agent Tools with Legible Boundaries

### Pattern
AI agents are multiplying—ChatGPT Atlas with "agent mode," Claude Code with sandboxing, autonomous research models. But the security model is still broken: prompt injection remains unsolvable (per Schneier/Raghavan), invisible attacks slip through screenshots, and malware hides in extension marketplaces. The pattern: powerful automation paired with opaque vulnerability.

### Tension
We want agents that act autonomously, but we also need to know what they're doing and constrain what they can touch. How do you give tools agency without surrendering your own?

### Coherenceism Lens
- **Primary**: Technology as Amplifier — Tools multiply what exists. If boundaries aren't clear, they amplify risk alongside capability.
- **Secondary**: Presence as Foundation — Attention reveals and maintains the pattern. Sandboxing (Claude Code's network isolation, filesystem boundaries) is presence built into tooling.

### Evidence
- Claude Code for web with sandboxing and network isolation (Simon Willison)
- Unseeable prompt injections in screenshots (Simon Willison)
- Prompt injection may be fundamentally unsolvable (Simon Willison quoting Schneier)
- ChatGPT Atlas with experimental agent mode (Simon Willison, Hacker News)
- GlassWorm security incident in extension marketplace (Lobsters)

### River Fit
Can someone reuse this tomorrow? The sandboxing patterns (filesystem/network boundaries) are immediately actionable. This is about choosing tools that maintain legibility even when autonomous.

---

## Seed 3: Learning by Building the Primitives

### Pattern
Educational resources are shifting from "how to use X framework" to "build your own database" and "implement a bytecode VM." The method: start from first principles, build the core yourself, understand the constraints that shaped existing tools.

### Tension
Frameworks let you move fast. Building from scratch feels slow. But which path gives you more agency when things break?

### Coherenceism Lens
- **Primary**: Build Once, Use Forever — Understanding primitives is a permanent capability. Once you've built a database, every database makes sense.
- **Secondary**: Nested Coherence — When you understand the inner layers, the outer layers stop being magic. You can see how local systems (your app) align with larger patterns (database design).

### Evidence
- Build your own database (Hacker News)
- A Fast Bytecode VM for Arithmetic (Lobsters)
- Why SSA? (Lobsters) — technical exploration of compiler internals
- Design of the SCHEME-78 Lisp-based microprocessor (Lobsters) — historical hardware primitives

### River Fit
Can someone reuse this tomorrow? These are learning methods, not just content. The approach—build the primitive, then use anything built on it—transfers across domains.

---

## Seed 4: Tools Shaped by Accident, Not Design

### Pattern
Modal editing (vi/Vim) exists because of 1970s terminal constraints, not because modes are the ideal interface. A 1995 diary entry captures how brutally complex early internet setup was—complexity that later generations inherited as "just how it works." Our current workflows often reflect frozen historical accidents rather than intentional design.

### Tension
We build new tools on top of old constraints that no longer exist. When should we question the shape of our tools instead of accepting them as natural?

### Coherenceism Lens
- **Primary**: Living Traditions — Evolve while honoring roots; forms adapt, patterns persist. Recognize when the root constraint is gone and the form can finally change.
- **Secondary**: Compost Cycles — Transform old constraints into nutrients for new growth. The history isn't waste; it's context that lets you see what's contingent versus essential.

### Evidence
- Modal editing is a weird historical contingency (Lobsters)
- Quoting Phil Gyford on 1995 internet setup challenges (Simon Willison)
- Magit is Amazing (Lobsters) — a tool that redesigns Git interaction from scratch

### River Fit
Can someone reuse this tomorrow? This is a lens for evaluating your own tools. Ask: which constraints here are real, and which are historical baggage? It's a reusable method for reclaiming agency from inherited complexity.
